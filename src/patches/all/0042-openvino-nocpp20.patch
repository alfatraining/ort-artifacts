diff --git a/onnxruntime/core/providers/openvino/openvino_provider_factory.cc b/onnxruntime/core/providers/openvino/openvino_provider_factory.cc
index 1a10d9849..07d17c24f 100644
--- a/onnxruntime/core/providers/openvino/openvino_provider_factory.cc
+++ b/onnxruntime/core/providers/openvino/openvino_provider_factory.cc
@@ -117,8 +117,10 @@ std::string ParseDeviceType(std::shared_ptr<OVCore> ov_core, const ProviderOptio
     luid_list = split(luid_str, ',');
   }
 
+  std::vector<std::string> selected_devices;
   for (auto device : devices_to_check) {
-    bool device_found = false;
+    // bool device_found = false;
+    const auto full_device_name = device;
     // Check deprecated device format (CPU_FP32, GPU.0_FP16, etc.) and remove the suffix in place
     // Suffix will be parsed in ParsePrecision
     if (auto delimit = device.find("_"); delimit != std::string::npos) {
@@ -134,9 +136,13 @@ std::string ParseDeviceType(std::shared_ptr<OVCore> ov_core, const ProviderOptio
         std::vector<std::string> available_devices = ov_core->GetAvailableDevices(device_prefix);
         // Here we need to find the full device name (with .idx, but without _precision)
         if (std::find(std::begin(available_devices), std::end(available_devices), device) != std::end(available_devices))
-          device_found = true;
-        if (!device_found) {
-          ORT_THROW("[ERROR] [OpenVINO] Device ", device, " is not available");
+        {
+          // device_found = true;
+          selected_devices.push_back(full_device_name);
+        }
+        else {
+          // ORT_THROW("[ERROR] [OpenVINO] Device ", device, " is not available");
+          continue;
         }
         if (device_prefix != "CPU" && luid_list.size() > 0) {
           for (const auto& dev : available_devices) {
@@ -180,8 +186,26 @@ std::string ParseDeviceType(std::shared_ptr<OVCore> ov_core, const ProviderOptio
       selected_device = std::move(ov_luid_devices);
     }
   }
+  else if(selected_devices.size() < 2)
+  {
+    selected_device = selected_devices.empty() ? "" : selected_devices.front();
+  }
+  else
+  {
+    selected_device.clear();
+    for(const auto &dev : selected_devices)
+    {
+      if(!selected_device.empty()) selected_device += ",";
+      selected_device += dev;
+    }
+
+    if(!device_mode.empty())
+    {
+      selected_device = device_mode + ":" + selected_device;
+    }
+  }
 
-  LOGS_DEFAULT(INFO) << "[OpenVINO-EP] Choosing Device: " << selected_device;
+  LOGS_DEFAULT(ERROR) << "[OpenVINO-EP] Choosing Device: " << selected_device;
   return selected_device;
 }
 
diff --git a/onnxruntime/core/providers/openvino/ov_factory.cc b/onnxruntime/core/providers/openvino/ov_factory.cc
index 2853cc177..0dba8a331 100644
--- a/onnxruntime/core/providers/openvino/ov_factory.cc
+++ b/onnxruntime/core/providers/openvino/ov_factory.cc
@@ -7,7 +7,7 @@
 #include <algorithm>
 #include <vector>
 #include <ranges>
-#include <format>
+// #include <format>
 
 #define ORT_API_MANUAL_INIT
 #include "onnxruntime_cxx_api.h"
@@ -170,7 +170,8 @@ OrtStatus* CreateEpFactories(const char* /*registration_name*/, const OrtApiBase
 
   const size_t required_factories = supported_factories.size();
   if (max_factories < required_factories) {
-    return Ort::Status(std::format("Not enough space to return EP factories. Need at least {} factories.", required_factories).c_str(), ORT_INVALID_ARGUMENT);
+    // return Ort::Status(std::format("Not enough space to return EP factories. Need at least {} factories.", required_factories).c_str(), ORT_INVALID_ARGUMENT);
+    return Ort::Status((std::string("Not enough space to return EP factories. Need at least ") + std::to_string(required_factories) + " factories.").c_str(), ORT_INVALID_ARGUMENT);
   }
 
   size_t factory_index = 0;
diff --git a/onnxruntime/core/providers/openvino/ov_interface.cc b/onnxruntime/core/providers/openvino/ov_interface.cc
index 899845d48..dd0617eac 100644
--- a/onnxruntime/core/providers/openvino/ov_interface.cc
+++ b/onnxruntime/core/providers/openvino/ov_interface.cc
@@ -3,8 +3,6 @@
 
 #include "core/providers/openvino/ov_interface.h"
 
-#include <format>
-
 #define ORT_API_MANUAL_INIT
 #include "core/session/onnxruntime_cxx_api.h"
 #include "core/providers/shared_library/provider_api.h"
@@ -16,14 +14,14 @@
 namespace onnxruntime {
 namespace openvino_ep {
 
-template <typename Func, typename... Args>
-inline auto OvExceptionBoundary(Func&& func, std::format_string<Args...>&& fmt, Args&&... args) {
+template <typename Func>
+inline auto OvExceptionBoundary(Func&& func, const std::string& message) {
   try {
     return func();
   } catch (const ov::Exception& e) {
-    ORT_THROW(log_tag + std::vformat(fmt.get(), std::make_format_args(args...)) + ": " + std::string(e.what()));
+    ORT_THROW(log_tag + message + ": " + std::string(e.what()));
   } catch (...) {
-    ORT_THROW(log_tag + std::vformat(fmt.get(), std::make_format_args(args...)));
+    ORT_THROW(log_tag + message);
   }
 }
 
@@ -172,7 +170,7 @@ OVExeNetwork OVCore::CompileModel(std::shared_ptr<const OVNetwork>& ie_cnn_netwo
 
     return exe;
   },
-                             "Exception while Loading Network for graph {}", name);
+                             "Exception while Loading Network for graph " + name);
 }
 
 OVExeNetwork OVCore::CompileModel(const std::string& onnx_model,
@@ -189,7 +187,7 @@ OVExeNetwork OVCore::CompileModel(const std::string& onnx_model,
     OVExeNetwork exe(obj, hw_target);
     return exe;
   },
-                             "Exception while Loading Network for graph {}", name);
+                             "Exception while Loading Network for graph " + name);
 }
 
 OVExeNetwork OVCore::ImportModel(ModelBlobWrapper& model_blob,
@@ -214,7 +212,7 @@ OVExeNetwork OVCore::ImportModel(ModelBlobWrapper& model_blob,
 #endif
     return exe;
   },
-                             "Exception while Loading Network for graph {}", name);
+                             "Exception while Loading Network for graph " + name);
 }
 
 OVExeNetwork OVCore::ImportEPCtxOVIREncapsulation(std::istream& model_stream,
@@ -267,7 +265,7 @@ OVExeNetwork OVCore::ImportEPCtxOVIREncapsulation(std::istream& model_stream,
 #endif
     return exe;
   },
-                             "Exception while Loading Network from OVIR model file: {}", model_file_path.string());
+                             "Exception while Loading Network from OVIR model file: " + model_file_path.string());
 }
 
 void OVCore::SetCache(const std::string& cache_dir_path) {
@@ -327,7 +325,6 @@ std::shared_ptr<OVInferRequest> OVExeNetwork::CreateInferRequest() {
     }
     return ovInfReq;
   },
-
                              "Exception while creating InferRequest object");
 }
 
@@ -337,7 +334,7 @@ OVTensorPtr OVInferRequest::GetTensor(const std::string& input_name) {
     OVTensorPtr blob = std::make_shared<OVTensor>(tobj);
     return blob;
   },
-                             " Cannot access IE Blob for input: {}", input_name);
+                             " Cannot access IE Blob for input: " + input_name);
 }
 
 std::string OVInferRequest::GetInputTensorName(uint32_t index) {
@@ -345,14 +342,14 @@ std::string OVInferRequest::GetInputTensorName(uint32_t index) {
     const auto& model = ovInfReq.get_compiled_model();
     return *model.input(index).get_names().begin();
   },
-                             " Cannot access IE Blob for input number: {}", index);
+                             " Cannot access IE Blob for input number: " + std::to_string(index));
 }
 
 void OVInferRequest::SetTensor(const std::string& name, OVTensorPtr& blob) {
   OvExceptionBoundary([&]() {
     ovInfReq.set_tensor(name, *(blob.get()));
   },
-                      " Cannot set Remote Blob for output: {}", name);
+                      " Cannot set Remote Blob for output: " + name);
 }
 
 uint32_t OVInferRequest::GetNumInputs() {
diff --git a/onnxruntime/core/providers/openvino/ov_interface.h b/onnxruntime/core/providers/openvino/ov_interface.h
index 38ea88307..f333d1eca 100644
--- a/onnxruntime/core/providers/openvino/ov_interface.h
+++ b/onnxruntime/core/providers/openvino/ov_interface.h
@@ -19,6 +19,8 @@
 #include "openvino/core/dimension.hpp"
 #include "openvino/core/partial_shape.hpp"
 
+#include "core/common/common.h"
+
 #include <string>
 
 namespace onnxruntime {
diff --git a/onnxruntime/core/providers/openvino/qdq_transformations/qdq_scales_fix.cpp b/onnxruntime/core/providers/openvino/qdq_transformations/qdq_scales_fix.cpp
index 3a39152b5..c094fee1e 100644
--- a/onnxruntime/core/providers/openvino/qdq_transformations/qdq_scales_fix.cpp
+++ b/onnxruntime/core/providers/openvino/qdq_transformations/qdq_scales_fix.cpp
@@ -269,18 +269,19 @@ struct GraphNode {
       return (val.has_value()) ? print_bool(val.value()) : "None";
     };
 
-    auto string = std::format("node_name={} op_type={} scale_factor={:.2f} visited={} queued={} down_to_output={} processed={} from_node={} to_node={} node_input_name={} node_output_name={}",
-                              node_name,
-                              op_type,
-                              scale_factor,
-                              visited,
-                              print_bool(queued),
-                              print_opt_bool(down_to_output),
-                              print_bool(processed),
-                              from_node_str,
-                              to_node_str,
-                              node_input_name_str,
-                              node_output_name_str);
+    char scale_factor_buf[32];
+    snprintf(scale_factor_buf, sizeof(scale_factor_buf), "%.2f", scale_factor);
+    auto string = std::string("node_name=") + node_name +
+                  " op_type=" + op_type +
+                  " scale_factor=" + scale_factor_buf +
+                  " visited=" + std::to_string(visited) +
+                  " queued=" + print_bool(queued) +
+                  " down_to_output=" + print_opt_bool(down_to_output) +
+                  " processed=" + print_bool(processed) +
+                  " from_node=" + from_node_str +
+                  " to_node=" + to_node_str +
+                  " node_input_name=" + node_input_name_str +
+                  " node_output_name=" + node_output_name_str;
     return string;
   }
 
@@ -536,7 +537,13 @@ struct CustomGraph {
 
       if (!found) {
         // Connect the last valid node to the graph output
-        for (auto node : std::ranges::reverse_view(original_graph.Nodes())) {
+        // Collect nodes into a vector to iterate in reverse
+        std::vector<const Node*> nodes_vec;
+        for (auto node : original_graph.Nodes()) {
+          nodes_vec.push_back(node);
+        }
+        for (auto it = nodes_vec.rbegin(); it != nodes_vec.rend(); ++it) {
+          auto node = *it;
           if (!node->OutputDefs().empty()) {
             const auto& name = (*node->OutputDefs().begin())->Name();
             auto& node_arg = original_graph.GetOrCreateNodeArg(name, output->TypeAsProto());
